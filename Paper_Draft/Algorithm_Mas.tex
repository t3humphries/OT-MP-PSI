% From http://tex.stackexchange.com/questions/164707/how-to-use-greek-letters-in-pgf-umlsd-or-generally-terms-starting-with
\renewcommand{\mess}[4][0]{
  \stepcounter{seqlevel}
  \path
  (#2)+(0,-\theseqlevel*\unitfactor-0.7*\unitfactor) node (mess from) {};
  \addtocounter{seqlevel}{#1}
  \path
  (#4)+(0,-\theseqlevel*\unitfactor-0.7*\unitfactor) node (mess to) {};
  \draw[->,>=angle 60] (mess from) -- (mess to) node[midway, above]
  {#3};
  \node (\detokenize{#3} from) at (mess from) {};
  \node (\detokenize{#3} to) at (mess to) {};
}

% From http://tex.stackexchange.com/questions/98525/pgf-umlsd-and-externalize
\newcommand{\sdinit}{%
   \pgfdeclarelayer{umlsd@background}%
   \pgfdeclarelayer{umlsd@threadlayer}%
   \pgfsetlayers{umlsd@background,umlsd@threadlayer,main}%
}
\newcommand{\sdbegin}{%
   \setlength{\unitlength}{1cm}%
   \tikzstyle{sequence}=[coordinate]%
   \tikzstyle{inststyle}=[rectangle, draw, anchor=west, minimum
   height=0.8cm, minimum width=1.6cm, fill=white, 
   drop shadow={opacity=1,fill=black}]%
   \ifpgfumlsdroundedcorners%
      \tikzstyle{inststyle}+=[rounded corners=3mm]%
   \fi%
   \tikzstyle{blockstyle}=[anchor=north west]%
   \tikzstyle{blockcommentstyle}=[anchor=north west, font=\small]%
   \tikzstyle{dot}=[inner sep=0pt,fill=black,circle,minimum size=0.2pt]%
   \global\def\unitfactor{0.6}%
   \global\def\threadbias{center}%
   % reset counters
   \setcounter{preinst}{0}%
   \setcounter{instnum}{0}%
   \setcounter{threadnum}{0}%
   \setcounter{seqlevel}{0}%
   \setcounter{callevel}{0}%
   \setcounter{callselflevel}{0}%
   \setcounter{blocklevel}{0}%
   % origin
   \node[coordinate] (inst0) {};%
}
\newcommand{\sdend}{%
   \begin{pgfonlayer}{umlsd@background}%
      \ifnum\value{instnum}>0%
         \foreach \t [evaluate=\t] in {1,...,\theinstnum}{%
            \draw[dotted] (inst\t) -- ++(0,-\theseqlevel*\unitfactor-2.2*\unitfactor);%
         }%
         
      \fi%
      \ifnum\value{threadnum}>0%
         \foreach \t [evaluate=\t] in {1,...,\thethreadnum}{%
            \path (thread\t)+(0,-\theseqlevel*\unitfactor-0.1*\unitfactor) node (threadend) {};%
            \tikzstyle{threadstyle}+=[threadcolor\t]%
            \drawthread{thread\t}{threadend}%
         }%
      \fi%
   \end{pgfonlayer}%
}
\subsection{Setup}
In over-threshold multi-party private set intersection there are three entity types: i) a key holder, ii) $m$ parties each holding at most $n$ elements, and iii) a reconstructor $\mathcal{R}$, who is also one of the $m$ parties. The parties want to learn what element appears at least $t$ times among the group and they should not learn anything else. We introduce two schemes of secret-shared oblivious pseudo-random functions (SS-OPRF) that achieve the goal through the following general steps:
\begin{enumerate}[label=(\alph*)]
    \item The key holder communicates with each party through an SS-OPRF scheme. During this communication, the key holder uses Shamir secret sharing scheme \cite{Shamir} to generate secret shares and MAC shares and send them to the party for each element owned by the party, while remaining oblivious to the elements. 
    \item The parties store their shares and the corresponding MACs for each element into bins, in order to facilitate the reconstruction process. 
    \item The reconstructor reconstructs all the possible secrets in each bin. Validating the results with the corresponding MACs reveals which elements were owned by at least $t$ parties. 
\end{enumerate}

\subsection{Notations, Assumptions, Trust Model}
\subsubsection{Notations} 
Table \ref{tab:Notations} defines the notations used in our schemes. 
\begin{table}[h!]
  \centering
  \caption{Notations}
  \label{tab:Notations}
  \begin{tabular}{ll}
    \toprule
     &  \\
    \midrule
    %\texttt{Random Walk} & 1 & (1, 1) & 0.1 & LOF\\
    m & The number of parties \\
    $id_i$ &  Identifier for party $i$; $i = 1, \dots, m$\\
    n &  Maximum size of the set of elements owned by a party ($n = \max_{i = 1, \dots, m}{|\mathbb{L}_i|}$)\\
    $\mathbb{L}_i$ & The set of elements owned by $id_i$; $i = 1, \dots, m$\\
    $\mathbb{L}$ & The set of all elements owned by parties ($\mathbb{L} = \cup_{i = 1, \dots, m}{\mathbb{L}_i}$)\\
    t &  threshold (intersection and the secret sharing threshold)\\
    h & number of key holders ($h=1$ in the default schemes)\\
    b &  number of bins (\textcolor{red}{$b = \frac{n}{\log{n}}?$}); bins are shown as $b_1, \dots, b_b$\\
    $H(\cdot)$ & Hash function used in the SS-OPRF schemes\\
    $H_B(\cdot)$ & Hash function used in hashing-to-bins\\
    $\mathbb{F}_p$ & The base prime field in SS-OPRF schemes\\
    $\mathbb{F}_q$ & The field for homomorphic encryption scheme\\
    $Enc_{pk}$ &  Encryption with public key $pk$ in the homomorphic encryption scheme\\
    $Dec_{sk}$ &  Decryption with private key $sk$ in the homomorphic encryption scheme\\   
    $K_1$ & The key holder's secret key used to generate secret shares for each element\\
    $K_2$ & The key holder's publicly known key used to generate the MAC for the secrets \\
    $Share_i(l)$ & Share of the element $l$ for party $i$\\
    $MAC_i(l)$ & Share of the MAC of the element $l$ for party $i$\\
    \bottomrule
  \end{tabular}
\end{table}

\subsubsection{Assumptions and Trust Model}
\begin{itemize}
    \item Each bin is padded to max
    \item Key holder is semi-honest
    \item Key holder is not a party, and does not collude with any party
    \item The reconstructor sees at most t-1 shares
\end{itemize}
\subsection{Scheme 1}
\subsubsection{Scheme Setup}
field $\mathbb{F}$ with prime p, generator g, hash functions $H(\cdot)$ is used in share generation and $H_B(\cdot)$ is used for hashing-to-bins, global randomnesses: i) key holder: $K_1$ and $K_2$; $K_1$ is just known by key holder, but $K_2$ is known by all, ii) the random numbers $r_1, \dots, r_{t-1} \gets \mathbb{F}_p$ generated by the key holder, that are fixed for all participants and their all elements. Participants use a homomorphic encryption scheme, Enc, with public and private keys $pk, sk$.
\subsubsection{Share Generation}\label{ShareGen_S1}
\begin{figure}[h!]
   \centering
   \sdinit{}
   \begin{tikzpicture}
      % Define symbols and names for the parties
      \sdbegin{}
      \newinst{A}{Key holder}
      \newinst[5]{B}{Participant} % Increase "5" to widen
      
    % Message from B to A, with computations by both sides
      \postlevel
      \mess{B}{$H(l)^\alpha, g^\alpha $}{A}
      \node[anchor=west] at (mess from) {\shortstack[c]{
            element \emph{l}, ${id_i}$ \\
            $\alpha \gets \mathbb{F}_p$}};
      \node[anchor=east] at (mess to) {$H(l)^{K_1 \alpha}$};

      \postlevel
      \postlevel
      \postlevel
      \mess{A}{\shortstack[l]{$g^{r \alpha}  H(l)^{K_1 \alpha}$, $\{g^{r \alpha} H(l)^{r_j \alpha}\}_{j = 1, \dots, t-1}$\\$g^{r \alpha}  H(l)^{K_1 \alpha}$, $\{g^{r \alpha} H(l)^{r'_j \alpha}\}_{j = 1, \dots, t-1}$ }}{B}
      \node[anchor=east] at (mess from) {\shortstack[c]{
      $r \gets \mathbb{F}_p$, Global $r_j$s\\
      $r \gets \mathbb{F}_p$, Global $r'_j$s
      }};
      \node[anchor=west] at (mess to) {\shortstack[l]{
      $g^{r} H(l)^{K_1}$, $\{g^{r} H(l)^{r_j}\}_{j = 1, \dots, t-1}$\\
      $g^{r} H(l)^{K_1}$, $\{g^{r} H(l)^{r'_j}\}_{j = 1, \dots, t-1}$
      }}; 
      
      \postlevel
      \postlevel
      \postlevel
      \postlevel
      \mess{B}{\shortstack[l]{$Enc_{pk}[g^r H(l)^{K_1}]$, $\{Enc_{pk}[g^{r}  H(l)^{r_j}]\}_{j = 1, \dots, t-1}$\\$Enc_{pk}[g^r H(l)^{K_1}]$, $\{Enc_{pk}[g^{r}  H(l)^{r'_j}]\}_{j = 1, \dots, t-1}$}}{A}
      \node[anchor=west] at (mess from) {\shortstack[l]{
            Enc: homomorphic \\encryption scheme}};
      \node[anchor=east] at (mess to) {\shortstack[l]{
      \hspace{0.1em} $Enc_{pk}[H(l)^{K_1}]$, \\ $\{Enc_{pk}[H(l)^{r_j}]\}_{j = 1, \dots, t-1}$ \vspace{1.2em}\\
      \hspace{0.1em} $Enc_{pk}[H(l)^{K_1}]$, \\$\{Enc_{pk}[H(l)^{r'_j}]\}_{j = 1, \dots, t-1}$}};

      \postlevel
      \postlevel
      \postlevel
      \postlevel
      \postlevel
      \mess{A}{\shortstack[c]{$P(id_i)$\\$P'(id_i)$}}{B}
      \node[anchor=east] at (mess from) {\shortstack[r]{
       $P(x) = \sum_{}x^j Enc[H(l)^{r_j}] $\\
       $ + Enc[H(l)^{K_1}]$
       \vspace{.3em}
       \\$P'(x) = \sum_{}x^j Enc[H(l)^{r'_j}] $\\
       $+ Enc[H(l)^{K_1K_2}]$}};
      \node[anchor=west] at (mess to) {\shortstack[c]{$Share_i(l) = Dec_{sk}[P(id_i)]$\\
      $MAC_i(l) = Dec_{sk}[P'(id_i)]$}};        
      \sdend{}
   \end{tikzpicture}
   \caption{Communication between the key holder and a participant $id_i$ in scheme 1 - Share generation for an element $l \in \mathbb{L}_i$, owned by $id_i$}
   \label{fig:S1_ShareGen}
\end{figure}
\begin{enumerate}[label=(\alph*)]
    \item Share generation for each element: Party $id_i$ generates a random number $\alpha$ to obliviously send its element's hash value, $H(l)$, to the key holder. The key holder generates a random number $r$ for this session\footnote{In each session, the key holder generates the share and its MAC for an element of a party} to mask the secret value $H(l)^{K_1 \alpha}$ and send it to the party. The key holder also uses $t$ global random numbers $r_1, \dots, r_{t-1} \gets \mathbb{F}_p$ to generate the coefficients of the polynomial $P(x)$ in Shamir secret sharing scheme. We use the term global to indicate that the same random numbers are used in all $mn$ sessions that generate the secret shares for $n$ elements for each of $m$ parties. The key holder communicates with each participant to generate shares for each participant's element using the polynomial $P(x)$. Since the exponentiation is not required for the rest of the protocol, the party removes the $\alpha$ exponent and encrypts the messages using a homomorphic encryption scheme. Figure \ref{fig:S1_ShareGen} shows the protocol taking place between the key holder and a participant with identifier identifier $id_i$, $i =1, \dots, m$, to generate shares for an element $l$. This protocol iterates over all elements $l \in \mathbb{L}$ to generate the corresponding share for each element owned by $id_i$.
    \item Share generation for the MAC of each element: Our schemes consist of two parallel procedures as shown in figures \ref{fig:S1_ShareGen} and \ref{fig:S2_ShareGen}. The first one is the generating the secret shares for each element as described in (a). The second procedure is generating shares for the MAC of the distributed secret in (a). The purpose of these MACs is to verify the secrets that are reconsrtucted later in Section \ref{alg:S1_Recon} by the reconstructor $\mathcal{R}$. The key holder uses a publicly known key $K_2$ to generate MACs for the elements' secrets. 
\end{enumerate}

\subsubsection{Hashing-to-bins}\label{Binning_S1}
Participants hash their shares to bins to reduce the computation cost for the reconstructor. Corresponding shares to an element $l$ are stored in bin number $H_B(l)$. Each stored value is a quadruple consisting of i) the participant's identifier, $id_i$, ii) $id_i$'s share for its element $l$, $Share_i(l)$, iii) the corresponding MAC, $MAC_i(l)$, and iv) the number of the bin, $H_B(l)$, that stores the information.

\subsubsection{Reconstruction}\label{Recon_S1}
After all participants stored their shares in the corresponding bins, the reconstructor  $\mathcal{R}$ -- who is also a participant -- reconstructs secrets in each bin. Recall that each bin might contain shares of several elements from each party. The reconstructor is not able to recognize which shares correspond to the same element. Hence, $\mathcal{R}$, forms all possible combinations of $t$ shares from distinct parties with the hope of finding the shares of the same elements. In order to find those shares, $\mathcal{R}$ uses the corresponding MACs to each set of shares that verifies if the shares in the set correspond to the same element. In other words, for each $m \choose t$ subset of the shares in the bin from distinct parties, $id_{i_1}, \dots, id_{i_t}$, $\mathcal{R}$ reconstructs the corresponding secret by applying Lagrange interpolation: $\sum^t_{w=0} Share_{i_w}(\cdot)(\prod_{w' \neq w} \frac{-id_{i_{w'}}}{id_{i_w} - id_{i_{w'}}})$. For a set of shares that correspond to element $l$, the Lagrange interpolation results in $H(l)^{k_1}$. Similarly, $\mathcal{R}$ calculates the corresponding MAC for the selected set of $t$ shares mentioned earlier, which equals $H(l)^{k_1 K_2}$ if the set of shares correspond to the element $l$. As the key $K_2$ is publicly known, $\mathcal{R}$ can verify the result of the Lagrange interpolation on the secret shares with the corresponding results of the MAC shares and validate the secret. These reconstruction steps are summarized in the Algorithm \ref{alg:S1_Recon}. 

\begin{algorithm}[h!]
	 \caption[\textsc{Reconstruct\textsubscript{Scheme1}}]{\textsc{Reconstruct\textsubscript{Scheme1}}}\label{alg:S1_Recon}
	 	\begin{algorithmic}[1]
	 	    \InlineComment{$K_1$ is key holder's secret key and $K_2$ is a publicly known key used for MAC generation}
	 		\InlineComment{$H(\cdot)$ is a hash function in share generation}
	 		\InlineComment{$H_B(\cdot)$ is a hash functions used for hashing-to-bin (Section \ref{Binning_S1})}
            \ForEach {Participant $id_i$;  $i = 1, \dots, m$}
                \ForEach {Element $l$ owned by $id_i$; $l \in \mathbb{L}_i$}
                    \State $id_i$: store $(id_i, Share_i(l), MAC_i(l), H_B(l))$ in the bin number $H_B(l)$
                    \State
	 	        \EndFor
	 	    \EndFor 
	 	    \ForEach {Bin $b_z$;  $z = 1, \dots, b$}
	 	        \ForEach {t-subset of quadruples in the bin $b_z$; $\{(id_{i_1}, Share_{i_1}(l), MAC_{i_1}(l), b_z), \dots, (id_{i_t}, Share_{i_t}(l), MAC_{i_t}(l), b_z)\}$, where $id_{i_i}$s are distinct,}
	 	            \State $\mathcal{R}$: Apply Lagrange interpolation to  find the corresponding intercept, $Secret_{share}$, for the polynomial that covers the points $\{({i_1}, Share_{i_1}), \dots, ({i_t}, Share_{i_t})\}$
	 	            \State $\mathcal{R}$: Apply Lagrange interpolation to  find the corresponding intercept, $Secret_{MAC}$, for the polynomial that covers the points $\{({i_1}, MAC_{i_1}), \dots, ({i_t}, MAC_{i_t})\}$
	 	            \If {$Secret_{MAC} == (Secret_{share})^{K_2}$}{ Reveal that $(id_{i_1}, \dots , id{i_t})$ can reconstruct the $Secret_{share}$ which is $H(l)^{K_1}$}
	 	            \EndIf 
	 	        \EndFor
	 	    \EndFor
	 	\end{algorithmic}
\end{algorithm}


\subsubsection{Complexity}
\begin{theorem}
The communication complexity of Scheme 1 in the number of rounds is $O(1)$. 
\end{theorem}
\begin{proof}
As shown in Figure \ref{fig:S1_ShareGen}, the communication between the key holder and each party takes places in two rounds, regardless of the number of parties, the number of elements or the threshold. Hence Scheme 1 is $O(1)$. 
\end{proof}
\begin{theorem}
The communication complexity of Scheme 1 in each rounds is $O(nmt)$, where $m$ is the number of parties, $n$ is the maximum size of the set of the elements owned by a party, and $t$ is the threshold in the over-threshold set intersection scheme.  
\end{theorem}
\begin{proof}
As shown in Figure \ref{fig:S1_ShareGen}, the key holder and the party communicate $t+3$ messages in the first round and $t+2$ messages in the second round. This communication is iterated $n$ times for each of $m$ parties to generate share for all of their elements. Hence, scheme 1 is $O(nmt)$.  
\end{proof}
\begin{theorem}\label{S1_ComputationComplexity}
The computation complexity of Scheme 1 is $O(b m^t (\log{n})^m)$; where $b$ is the number of bins, $m$ is the number of parties, and $t$ is the threshold value in the over-threshold set intersection scheme.
\end{theorem}
\begin{proof}
As described in Algorithm \ref{alg:S1_Recon}, the reconstructor $\mathcal{R}$ forms all possible combinations of $t$ shares from distinct parties in each bin. There are $m \choose t$ ways for choosing a set of $t$ distinct parties out of $m$ of them. Moreover, each of these parties have $\log{n}$ shares in each bin. Hence, forming a set of $t$ shares from distinct parties in a bin takes $m^t (\log{n})^m$ combinations. This procedure iterates $b$ times to cover all the bins.  
\end{proof}

\subsection{Scheme 2}
\subsubsection{Scheme Setup}
In this scheme, the polynomial in Shamir secret sharing scheme is calculated in the exponent, the result is eliminating the need to use the homomorphic encryption scheme, Enc. This change reduces the communication cost of the scheme as described in Section \ref{ShareGen_S2}. Similar to Scheme 1, we have the following set up parameters: field $\mathbb{F}$ with prime p, generator g, hash functions $H(\cdot)$ is used in share generation and $H_B(\cdot)$ is used for hashing-to-bins, global randomnesses: i) key holder: $K_1$ and $K_2$; $K_1$ is just known by key holder, but $k_2$ is known by all, ii) the random numbers $r_1, \dots, r_{t-1} \gets \mathbb{F}_p$ generated by the key holder, that are fixed for all participants and their all elements. 

\begin{figure}[h!]
   \centering
   \sdinit{}
   \begin{tikzpicture}
      % Define symbols and names for the parties
      \sdbegin{}
      \newinst{A}{Key holder}
      \newinst[5]{B}{Participant} % Increase "5" to widen
      
    % Message from B to A, with computations by both sides
    %   \postlevel
    %   \mess{A}{\shortstack[l]{$\{g^{r_i}\}_{i = 1, \dots, t-1}$\\$\{g^{r'_i}\}_{i = 1, \dots, t-1}$ }}{B}
    %   \node[anchor=east] at (mess from) {\shortstack[l]{
    %   For global $r_i$s\\
    %   And global $r'_i$s
    %   }};
    %   \node[anchor=west] at (mess to) {\shortstack[l]{
    %   $\{g^{r_i}\}_{i = 1, \dots, t-1}$\\
    %   $\{g^{r'_i}\}_{i = 1, \dots, t-1}$
    %   }}; 
    
      \postlevel
      \postlevel
      \mess{B}{$H(l)^\alpha$}{A}
    %   \mess{B}{\shortstack[l]{$H(l)^\alpha , \{g^{r_i \alpha}\}_{i = 1, \dots, t-1}$ \\ $H(l)^\alpha , \{g^{r'_i \alpha}\}_{i = 1, \dots, t-1}$}}{A}      
       \node[anchor=west] at (mess from) {\shortstack[c]{
            element \emph{l}, \emph{id} \\
            $\alpha \gets \mathbb{F}_p$}};
    \node[anchor=east] at (mess to) {\shortstack[l]{$H(l)^{\alpha K_1}, \{H(l)^{r_i \alpha}\}_{i = 1, \dots, t-1}$ \\ $H(l)^{\alpha K_1 K_2}, \{H(l)^{r'_i \alpha}\}_{i = 1, \dots, t-1}$}};
    %   \node[anchor=east] at (mess to) {\shortstack[l]{$H(l)^{\alpha K_1}, \{g^{r_i \alpha}\}_{i = 1, \dots, t-1}$ \\ $H(l)^{\alpha K_1 K_2}, \{g^{r'_i \alpha}\}_{i = 1, \dots, t-1}$}};
      
      \postlevel
      \postlevel
      \mess{A}{\shortstack[c]{$P(id)$\\$P'(id)$}}{B}
      \node[anchor=east] at (mess from) {\shortstack[r]{
       $P(x) = H(l)^{\alpha \sum_{}r_i x^i} H(l)^{\alpha K_1}$
       \vspace{.4em}
       \\$P'(x) = H(l)^{\alpha \sum_{}r'_i x^i} H(l)^{\alpha K_1 K_2}$}};
      \node[anchor=west] at (mess to) {\shortstack[c]{$Share(l) = P(id)^{1/ \alpha}$\\
      $MAC(l) = P'(id)^{1/ \alpha}$}};        
      
      \sdend{}
   \end{tikzpicture}
   \caption{Communication between the key holder and a participant $id_i$ in scheme 2 - Share generation for an element $l \in \mathbb{L}_i$, owned by $id_i$}
   \label{fig:S2_ShareGen}
\end{figure}

\subsubsection{Share Generation}\label{ShareGen_S2}
\begin{enumerate}[label=(\alph*)]
    \item Share generation for the element: Party $id_i$ generates a random number $\alpha$ to obliviously send an element's hash, $H(l)$, to the key holder. The key holder generates global random numbers $r_1, \dots, r_{t-1} \gets \mathbb{F}_p$. Then it communicates with each participant to generate shares for each participant's element using Shamir secret sharing scheme, by forming a polynomial in the exponent. Figure \ref{fig:S2_ShareGen} shows the protocol taking place between the key holder and a participant with identifier identifier $id_i$, $i =1, \dots, m$, to generate shares for an element $l$. This protocol iterates over all elements $l \in \mathbb{L}$ to generate the corresponding share for each element owned by $id_i$.
    \item Share generation for the MAC of each element: As described in MAC generation in Section \ref{ShareGen_S1}(b), our schemes consist of a MAC generation procedure in parallel to the share generation for secrets. Similar to the procedure in  Section \ref{ShareGen_S1}(b), the key holder in scheme 2 uses a publicly known key $K_2$ to generate MACs for the elements' secrets. The Mac's are used in the reconstruction phase in Section \ref{Recon_S2} to verify the reconstructed secrets. 
\end{enumerate}

\subsubsection{Hashing-to-bins}\label{Binning_S2} This step is identical to the hashing-to-bins described in Section \ref{Binning_S1}.

\subsubsection{Reconstruction}\label{Recon_S2}
The reconstruction procedure of sceheme 2 is similar to the reconstruction in Section \ref{Recon_S1} for Scheme 1. Each party's shares are hashed into the corresponding bins, with each bin containing multiple shares of each party. The reconstructor $\mathcal{R}$ --who is also participant-- reconstructs the secrets in each bin for every $m \choose t$ subset of shares for distinct parties, $id_{i_1}, \dots, id_{i_t}$. As the polynomial is in the exponent of the generator in this scheme, the reconstructor applies the Lagrange interpolation in the exponent to calculate the secret as follows: $H(l)^{k_1} = \prod^t_{w=0} Share_{i_w}(\cdot)^{(\prod_{w' \neq w} \frac{-id_{w'}}{id_w - id_{w'}})}$. $\mathcal{R}$ verifies if the selected set of shares correspond to the same element by calculating the MAC of the set and evaluating the results of the two calculations. These reconstruction steps are summarized in the Algorithm \ref{alg:S2_Recon}. 

\begin{algorithm}[h!]
	 \caption[\textsc{Reconstruct\textsubscript{Scheme2}}]{\textsc{Reconstruct\textsubscript{Scheme2}}}\label{alg:S2_Recon}
	 	\begin{algorithmic}[1]
	 	    \InlineComment{$K_1$ is key holder's secret key and $K_2$ is a publicly known key used for MAC generation}
	 		\InlineComment{$H(\cdot)$ is a hash function in share generation}
	 		\InlineComment{$H_B(\cdot)$ is a hash functions used for hashing-to-bin (Section \ref{Binning_S1})}
            \ForEach {Participant $id_i$;  $i = 1, \dots, m$}
                \ForEach {Element $l$ owned by $id_i$; $l \in \mathbb{L}_i$}
                    \State $id_i$: store $(id_i, Share_i(l), MAC_i(l), H_B(l))$ in the bin number $H_B(l)$
                    \State
	 	        \EndFor
	 	    \EndFor 
	 	    \ForEach {Bin $b_z$;  $z = 1, \dots, b$}
	 	        \ForEach {t-subset of quadruples in the bin $b_z$; $\{(id_{i_1}, Share_{i_1}(l), MAC_{i_1}(l), b_z), \dots, (id_{i_t}, Share_{i_t}(l), MAC_{i_t}(l), b_z)\}$, where $id_{i_i}$s are distinct,}
	 	            \State $\mathcal{R}$: Reconstruct the corresponding secret, $Secret_{share}$, to the points $\{({i_1}, Share_{i_1}), \dots, ({i_t}, Share_{i_t})\}$
	 	            \State $\mathcal{R}$: Reconstruct the corresponding secret, $Secret_{MAC}$, to the points $\{({i_1}, MAC_{i_1}), \dots, ({i_t}, MAC_{i_t})\}$
	 	            \If {$Secret_{MAC} == (Secret_{share})^{K_2}$}{ Reveal that $(id_{i_1}, \dots , id{i_t})$ can reconstruct the $Secret_{share}$ which is $H(l)^{K_1}$}
	 	            \EndIf 
	 	        \EndFor
	 	    \EndFor
	 	\end{algorithmic}
\end{algorithm}

\subsubsection{Complexity}
\begin{theorem}
The communication complexity of Scheme 2 in the number of rounds is $O(1)$. 
\end{theorem}
\begin{proof}
As shown in Figure \ref{fig:S2_ShareGen}, the communication between the key holder and each party takes places in one rounds, regardless of the number of parties, the number of elements or the threshold. Hence Scheme 1 is $O(1)$. 
\end{proof}
\begin{theorem}
The communication complexity of Scheme 2 in each rounds is $O(nm)$, where $m$ is the number of parties and $n$ is the maximum size of the set of the elements owned by a party. 
\end{theorem}
\begin{proof}
As shown in Figure \ref{fig:S2_ShareGen}, the key holder and the party communicate $2$ messages in the round. This communication is iterated $n$ times for each of $m$ parties to generate share for all of their elements. Hence, scheme 1 is $O(nm)$.  
\end{proof}
\begin{theorem}
The computation complexity of Scheme 2 is $O(b m^t (\log{n})^m)$; where $b$ is the number of bins, $m$ is the number of parties, and $t$ is the threshold value in the over-threshold set intersection scheme.
\end{theorem}
\begin{proof}
The proof follows the same reasoning as the proof of Theorem \ref{S1_ComputationComplexity}. 
As described in Algorithm \ref{alg:S2_Recon}, the reconstructor $\mathcal{R}$ forms all possible combinations of $t$ shares from distinct parties in each bin. There are $m \choose t$ options for choosing a set of $t$ distinct parties out of $m$ of them. Moreover, each of these parties have $\log{n}$ shares in each bin. Hence, forming a set of $t$ shares from distinct parties in a bin takes $m^t (\log{n})^m$ combinations. This procedure iterates $b$ times to cover all the bins.  
\end{proof}

\subsection{Additional Notes}
\subsubsection{Statistical Secret Sharing Scheme}
Our protocol requires switching between two fields to perform the share generation, described in Figures \ref{fig:S1_ShareGen} and \ref{fig:S2_ShareGen}: i) the base prime field $\mathbb{F}_p$ and ii) the field $\mathbb{F}_q$ in which the homomorphic encryption is performed. We use the statistical secret sharing scheme introduced in  \cite{Statistical_SSS} to covert a secret-shared message over a prime field to another field. 
\subsubsection{Multi-Reconstructor Scheme}
We described in Algorithms \ref{alg:S1_Recon} and \ref{alg:S2_Recon} how the reconstructor $\mathcal{R}$ reconstructs the secrets in each bin. We emphasize the reconstruction is not restricted to a single party and can be performed by multiple parties in parallel. 
\subsubsection{Multi key holder Scheme}
We can extend our schemes from a single key holder scenario to a multi key holder one. In this extension, all or a subset of all parties form the key holders set. They key holders run a multi-party protocol among themselves to form the followings from their keys and random numbers: i) a group key, ii) group random numbers. The group key serves as the key holder key $K_1$ in the Schemes 1 and 2 (Figures \ref{fig:S1_ShareGen} and \ref{fig:S2_ShareGen}), and the group random numbers serve as $r, r'$ and $r_j, r'_j; j=1,\dots,t-1$ in the Scheme 1 and as $r_j, r'_j; j=1,\dots,t-1$ in Scheme 2. The multi key holder scheme follows the exact same procedure as in Schemes 1 and 2 otherwise.
