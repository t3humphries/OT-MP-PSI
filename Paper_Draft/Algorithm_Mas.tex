% From http://tex.stackexchange.com/questions/164707/how-to-use-greek-letters-in-pgf-umlsd-or-generally-terms-starting-with
\renewcommand{\mess}[4][0]{
  \stepcounter{seqlevel}
  \path
  (#2)+(0,-\theseqlevel*\unitfactor-0.7*\unitfactor) node (mess from) {};
  \addtocounter{seqlevel}{#1}
  \path
  (#4)+(0,-\theseqlevel*\unitfactor-0.7*\unitfactor) node (mess to) {};
  \draw[->,>=angle 60] (mess from) -- (mess to) node[midway, above]
  {#3};
  \node (\detokenize{#3} from) at (mess from) {};
  \node (\detokenize{#3} to) at (mess to) {};
}

% From http://tex.stackexchange.com/questions/98525/pgf-umlsd-and-externalize
\newcommand{\sdinit}{%
   \pgfdeclarelayer{umlsd@background}%
   \pgfdeclarelayer{umlsd@threadlayer}%
   \pgfsetlayers{umlsd@background,umlsd@threadlayer,main}%
}
\newcommand{\sdbegin}{%
   \setlength{\unitlength}{1cm}%
   \tikzstyle{sequence}=[coordinate]%
   \tikzstyle{inststyle}=[rectangle, draw, anchor=west, minimum
   height=0.8cm, minimum width=1.6cm, fill=white, 
   drop shadow={opacity=1,fill=black}]%
   \ifpgfumlsdroundedcorners%
      \tikzstyle{inststyle}+=[rounded corners=3mm]%
   \fi%
   \tikzstyle{blockstyle}=[anchor=north west]%
   \tikzstyle{blockcommentstyle}=[anchor=north west, font=\small]%
   \tikzstyle{dot}=[inner sep=0pt,fill=black,circle,minimum size=0.2pt]%
   \global\def\unitfactor{0.6}%
   \global\def\threadbias{center}%
   % reset counters
   \setcounter{preinst}{0}%
   \setcounter{instnum}{0}%
   \setcounter{threadnum}{0}%
   \setcounter{seqlevel}{0}%
   \setcounter{callevel}{0}%
   \setcounter{callselflevel}{0}%
   \setcounter{blocklevel}{0}%
   % origin
   \node[coordinate] (inst0) {};%
}
\newcommand{\sdend}{%
   \begin{pgfonlayer}{umlsd@background}%
      \ifnum\value{instnum}>0%
         \foreach \t [evaluate=\t] in {1,...,\theinstnum}{%
            \draw[dotted] (inst\t) -- ++(0,-\theseqlevel*\unitfactor-2.2*\unitfactor);%
         }%
         
      \fi%
      \ifnum\value{threadnum}>0%
         \foreach \t [evaluate=\t] in {1,...,\thethreadnum}{%
            \path (thread\t)+(0,-\theseqlevel*\unitfactor-0.1*\unitfactor) node (threadend) {};%
            \tikzstyle{threadstyle}+=[threadcolor\t]%
            \drawthread{thread\t}{threadend}%
         }%
      \fi%
   \end{pgfonlayer}%
}
\subsection{Setup}
In over-threshold multi-party private set intersection there are three entity types: i) $m$ parties each holding at most $n$ elements, ii) $k$ key holders, who are among the $m$ parties, and iii) $r$ reconstructors, who are also among the $m$ parties. First, we consider the case of $k = r = 1$ where also the keyholder and reconstructor $\mathcal{R}$ need to be distinct and extend it to the multi-party case in Section~\ref{sec:addnotes}. The parties want to learn what element appears at least $t$ times among the group, and who the owners are. We introduce two schemes of secret-shared oblivious pseudo-random functions (SS-OPRF) that achieve the goal through the following general steps:
\begin{enumerate}[label=(\alph*)]
    \item The key holder communicates with each party through an SS-OPRF scheme. During this communication, the key holder uses Shamir secret sharing scheme \cite{Shamir} to generate secret shares and MAC shares and send them to the party for each element owned by the party, while remaining oblivious to the elements. 
    \item The parties store their shares and the corresponding MACs for each element into bins, in order to facilitate the reconstruction process. 
    \item The reconstructor reconstructs all the possible secrets in each bin. Validating the results with the corresponding MACs reveals which elements were owned by at least $t$ parties. 
\end{enumerate}

\subsection{Notations, Assumptions, Trust Model}
\subsubsection{Notations} 
Table \ref{tab:Notations} defines the notations used in our schemes. \bmargin{*}{for $k_2$ in the table, publicly known or just public}
\begin{table}[h!]
  \centering
  \caption{Notations}
  \label{tab:Notations}
  \begin{tabular}{ll}
    \toprule
     &  \\
    \midrule
    %\texttt{Random Walk} & 1 & (1, 1) & 0.1 & LOF\\
    m & The number of parties \\
    $id_i$ &  Identifier for party $i$; $i = 1, \dots, m$\\
    n &  Maximum size of the set of elements owned by a party ($n = \max_{i = 1, \dots, m}{|\mathbb{L}_i|}$)\\
    $\mathbb{L}_i$ & The set of elements owned by $id_i$; $i = 1, \dots, m$\\
    $\mathbb{L}$ & The set of all elements owned by parties ($\mathbb{L} = \cup_{i = 1, \dots, m}{\mathbb{L}_i}$)\\
    t &  threshold (intersection and the secret sharing threshold)\\
    h & number of key holders ($h=1$ in the default schemes)\\
    b &  number of bins ($b = \frac{n}{\log{n}}$); bins are shown as $b_1, \dots, b_b$\\
    $|b_i|$ & The size of the bin $b_i$, which is $c \times \log{n}$; for $i=1, \cdots, b$\\
    $H(\cdot)$ & Hash function used in the SS-OPRF schemes\\
    $H_B(\cdot)$ & Hash function used in hashing-to-bins\\
    $\GG_q$ & The group or the PRF\\
    $\mathbb{F}_p$ & The base prime field in SS-OPRF schemes\\
    $\mathbb{F}_N$ & The field of the plaintext of the homomorphic encryption scheme\\
    $\mathbb{F}_{N^2}$ & The field of the ciphertext of the homomorphic encryption scheme\\
    $Enc_{pk}$ &  Encryption with public key $pk$ in the homomorphic encryption scheme\\
    $Dec_{sk}$ &  Decryption with private key $sk$ in the homomorphic encryption scheme\\   
    $K_1$ & The key holder's secret key used to generate secret shares for each element\\
    $K_2$ & The key holder's publicly known key used to generate the MAC for the secrets \\
    $Share_i(\ell)$ & Share of the element $\ell$ for party $i$\\
    $MAC_i(\ell)$ & Share of the MAC of the element $\ell$ for party $i$\\
    \bottomrule
  \end{tabular}
\end{table}

\subsubsection{Assumptions and Trust Model}
\begin{itemize}
    \item Each bin is padded to max
    \item Key holder is semi-honest
    \item Key holder is a party, and does not collude with the reconstructor
    \item The reconstructor does not collude with more than t-2 (non-key-holder)
    parties
\end{itemize}

\subsection{Scheme 1}\bmargin{*}{Replacing $l$ with $\ell$. I will try not to miss any; for readability $l$ can look like $1$ to people, especially with subscripts involved at points}
\subsubsection{Scheme Setup}
We have the following set up parameters: field $\mathbb{F}_p$ with prime $p = 2q + 1$, generator $g$ of subgroup $\GG_q$, hash function $H(\cdot)$ is used in share generation and $H_B(\cdot)$ is used for hashing-to-bins, global randomnesses: i) the secret key $K_1$, just known by key holder, ii) the random numbers $c_1, \ldots, c_{t-1} \sample \mathbb{Z}_{q}$ generated by the key holder, that are fixed for all participants and their all elements. These random numbers are used to calculate the coefficients of the polynomial in Shamir secret sharing scheme. This polynomial is calculated in the exponent of $H(\ell)$ in $P(x)$ as shown in Figure \ref{fig:S2_ShareGen}.

\begin{figure}[h!]
   \centering
   \sdinit{}
   \begin{tikzpicture}
      % Define symbols and names for the parties
      \sdbegin{}
      \newinst{A}{Key holder}
      \newinst[5]{B}{Participant} % Increase "5" to widen

      \postlevel
      \postlevel
      \mess{B}{$H(\ell)^\alpha$}{A}
    %   \mess{B}{\shortstack[l]{$H(l)^\alpha , \{g^{r_i \alpha}\}_{i = 1, \dots, t-1}$ \\ $H(l)^\alpha , \{g^{r'_i \alpha}\}_{i = 1, \dots, t-1}$}}{A}      
       \node[anchor=west] at (mess from) {\shortstack[c]{
            element \emph{$\ell$}, \emph{id} \\
            $\alpha \gets \mathbb{F}_{\phi(p)}$}};
    \node[anchor=east] at (mess to) {\shortstack[l]{$H(\ell)^{\alpha K_1}, \{H(\ell)^{c_i \alpha}\}_{i = 1, \dots, t-1}$ \\ $H(\ell)^{\alpha K_1}, \{H(\ell)^{c'_i \alpha}\}_{i = 1, \dots, t-1}$}};
      
      \postlevel
      \postlevel
      \mess{A}{\shortstack[c]{$P(id)$\\$P'(id)$}}{B}
      \node[anchor=east] at (mess from) {\shortstack[r]{
       $P(x) = H(\ell)^{\alpha \sum_{}c_i x^i} H(\ell)^{\alpha K_1}$
       \vspace{.4em}
       \\$P'(x) = H(\ell)^{\alpha \sum_{}c'_i x^i} H(\ell)^{\alpha K_1}$}};
      \node[anchor=west] at (mess to) {\shortstack[c]{$Share(\ell) = P(id)^{1/ \alpha}$\\
      $MAC(\ell) = P'(id)^{1/ \alpha}$}};        
      
      \sdend{}
   \end{tikzpicture}
   \caption{Communication between the key holder and a participant $id_i$ in Scheme 1 - Share generation for an element $\ell \in \mathbb{L}_i$, owned by $id_i$}
   \label{fig:S2_ShareGen}
\end{figure}
\subsubsection{Share Generation}\label{ShareGen_S2}
\begin{enumerate}[label=(\alph*)]
    \item Share generation for the element: Party $id_i$ generates a random number $\alpha$ to obliviously send an element's hash, $H(\ell)$, to the key holder. The key holder generates global random numbers $c_1, \dots, c_{t-1} \gets \mathbb{Z}_{q}$. Then it communicates with each participant to generate shares for each participant's element using Shamir secret sharing by forming a polynomial in the exponent. Figure \ref{fig:S2_ShareGen} shows the protocol taking place between the key holder and a participant with identifier identifier $id_i$, $i =1, \dots, m$, to generate shares for an element $\ell$. This protocol iterates over all elements $\ell \in \mathbb{L}_i$ to generate the corresponding share for each element owned by $id_i$.
    \item Our schemes consist of two parallel procedures as shown in Figures \ref{fig:S2_ShareGen} and \ref{fig:S1_ShareGen}. The first one is the generating the secret shares for each element as described in (a). The second procedure is generating shares for the MAC of the distributed secret in (a). The purpose of these MACs is to verify the secrets that are reconstructed later in Section \ref{alg:S1_Recon} by the reconstructor $\mathcal{R}$. The key holder uses a second polynomial $P'(x)$ to generate MACs for the elements' secrets. 
\end{enumerate}

\subsubsection{Hashing-to-bins}\label{Binning_S2} 
Participant' hash their shares to $b$ (=$\frac{n}{\log{n}}$) bins, each of size $c\times \log{n}$\fmargin{*}{Maybe this should $O(\log{n})$} to reduce the computation cost for the reconstructor. Corresponding shares to an element $\ell$ are stored in bin number $H_B(\ell)$. Each stored value is a quadruple consisting of i) the participant's identifier, $id_i$, ii) $id_i$'s share for its element $\ell$, $Share_i(\ell)$, iii) the corresponding MAC, $MAC_i(\ell)$, and iv) the number of the bin, $H_B(\ell)$, that stores the information.

\subsubsection{Reconstruction}\label{Recon_S2}
After all participants store their shares in the corresponding bins, the reconstructor $\mathcal{R}$ -- who is also a participant -- reconstructs secrets in each bin. Recall that each bin might contain shares of several elements from each party. The reconstructor is not able to recognize which shares correspond to the same element. Hence, $\mathcal{R}$, forms all possible combinations of $t$ shares -- $m \choose t$ -- from distinct parties, $id_{i_1}, \dots, id_{i_t}$, with the hope of finding the shares of the same elements. In order to find those shares, $\mathcal{R}$ uses the corresponding MACs to each set of shares that verifies if the shares in the set correspond to the same element. As the polynomial is in the exponent of the generator in this scheme, the reconstructor applies the Lagrange interpolation in the exponent to calculate the secret as follows: $H(\ell)^{K_1} = \prod^t_{w=0} Share_{i_w}(\cdot)^{(\prod_{w' \neq w} \frac{-id_{w'}}{id_w - id_{w'}})}$. $\mathcal{R}$ verifies if the selected set of shares correspond to the same element by calculating the MAC of the set and evaluating the results of the two calculations. These reconstruction steps are summarized in the Algorithm \ref{alg:S2_Recon}. 

\begin{algorithm}[h!]
	 \caption[\textsc{Reconstruct\textsubscript{Scheme2}}]{\textsc{Reconstruct\textsubscript{Scheme2}}}\label{alg:S2_Recon}
	 	\begin{algorithmic}[1]
	 	    \InlineComment{$K_1$ is key holder's secret key and $K_2$ is a publicly known key used for MAC generation}
	 		\InlineComment{$H(\cdot)$ is a hash function in share generation}
	 		\InlineComment{$H_B(\cdot)$ is a hash functions used for hashing-to-bin (Section \ref{Binning_S1})}
            \ForEach {Participant $id_i$;  $i = 1, \dots, m$}
                \ForEach {Element $\ell$ owned by $id_i$; $\ell \in \mathbb{L}_i$}
                    \State $id_i$: store $(id_i, Share_i(\ell), MAC_i(\ell), H_B(\ell))$ in the bin number $H_B(\ell)$
                    \State
	 	        \EndFor
	 	    \EndFor 
	 	    \ForEach {Bin $b_z$;  $z = 1, \dots, b$}
	 	        \ForEach {t-subset of quadruples in the bin $b_z$; $\{(id_{i_1}, Share_{i_1}(\ell), MAC_{i_1}(\ell), b_z), \dots, (id_{i_t}, Share_{i_t}(\ell), MAC_{i_t}(\ell), b_z)\}$, where $id_{i_i}$s are distinct,}
	 	            \State $\mathcal{R}$: Reconstruct the corresponding secret, $Secret_{share}$, to the points $\{({i_1}, Share_{i_1}), \dots, ({i_t}, Share_{i_t})\}$
	 	            \State $\mathcal{R}$: Reconstruct the corresponding secret, $Secret_{MAC}$, to the points $\{({i_1}, MAC_{i_1}), \dots, ({i_t}, MAC_{i_t})\}$
	 	            \If {$Secret_{MAC} == Secret_{share}$}{ Reveal that $(id_{i_1}, \dots , id{i_t})$ can reconstruct the $Secret_{share}$ which is $H(\ell)^{K_1}$}
	 	            \EndIf 
	 	        \EndFor
	 	    \EndFor
	 	\end{algorithmic}
\end{algorithm}

\subsubsection{Complexity}
We analyse the complexity of Scheme 1 in its base version with a single key holder. We discuss the multi key holder case in Section \ref{Multi-Key-Holder}.
\begin{theorem}
The communication complexity of Scheme 1 in the number of rounds is $O(1)$. 
\end{theorem}
\begin{proof}
As shown in Figure \ref{fig:S2_ShareGen}, the communication between the key holder and each party takes places in one rounds, regardless of the number of parties, the number of elements or the threshold. Hence Scheme 2 is $O(1)$. 
\end{proof}
\begin{theorem}
The communication complexity of Scheme 1 in each rounds is $O(nm)$, where $m$ is the number of parties and $n$ is the maximum size of the set of the elements owned by a party. 
\end{theorem}
\begin{proof}
As shown in Figure \ref{fig:S2_ShareGen}, the key holder and the party communicate $2$ messages in the round. This communication is iterated $n$ times for each of $m$ parties to generate share for all of their elements. Hence, Scheme 2 is $O(nm)$.  
\end{proof}
\begin{theorem}
The computation complexity of Scheme 1 is $O(b m^t (\log{n})^t)$\footnote{The computation complexity is $O(b m^t (\log{n})^t)$ for small values of $t$. For large values of $t$ and $m$, the complexity is $O(2^m (\log{n})^t)$.}; where $b = O(\frac{n}{\log{n}})$ is the number of bins, $m$ is the number of parties, and $t$ is the threshold value in the over-threshold set intersection scheme. 
\end{theorem}
\begin{proof}
The proof follows the same reasoning as the proof of Theorem \ref{S1_ComputationComplexity}. 
As described in Algorithm \ref{alg:S2_Recon}, the reconstructor $\mathcal{R}$ forms all possible combinations of $t$ shares from distinct parties in each bin. There are $m \choose t$ options for choosing a set of $t$ distinct parties out of $m$ of them. Moreover, each of these parties have $\log{n}$ shares in each bin. Hence, forming a set of $t$ shares from distinct parties in a bin takes $m^t (\log{n})^t$ combinations. This procedure iterates $b$ times to cover all the bins.  
\end{proof}

\subsection{Scheme 2}

The reconstruction in Scheme 1 has very high constants, since Lagrange interpolation is executed in the exponent and modular exponentiations are slow.
To improve the reconstruction time, we construct Scheme 2 with Lagrange interpolation in the base.
This is challenging, since the PRF requires exponentiation, but secret sharing requires addition.
No cryptographic scheme supports both operations on its plaintext securely.
Hence, we use a conversion between two schemes -- discrete logs and additively homomorphic encryption.

\subsubsection{Scheme Setup}
Similar to Scheme 1, this scheme uses field $\mathbb{F}_p$ with prime $p = 2q + 1$, generator $g$ of subgroup $\GG_q$, hash function $H(\cdot)$ is used in share generation and $H_B(\cdot)$ is used for hashing-to-bins, global randomnesses: i) $K_1$ known and used by key holder, ii) the random numbers $c_1, \dots, c_{t-1}, c'_1, \ldots, c_{t-1} \sample \mathbb{Z}_{q}$ generated by the key holder, that are fixed for all participants and their all elements. These random numbers are used to calculate the coefficients of the polynomial in Shamir secret sharing scheme. Participants use a homomorphic encryption scheme, Enc, over plaintext field $\FF_N$ where $N > 2^\lambda p^2$. % with public and private keys $pk, sk$.
\subsubsection{Share Generation}\label{ShareGen_S1}
\begin{figure}[h!]
   \centering
   \sdinit{}
   \begin{tikzpicture}
      % Define symbols and names for the parties
      \sdbegin{}
      \newinst{A}{Key holder}
      \newinst[5]{B}{Participant} % Increase "5" to widen
      
    % Message from B to A, with computations by both sides
      \postlevel
      \mess{B}{$H(\ell)^\alpha, g^\alpha $}{A}
      \node[anchor=west] at (mess from) {\shortstack[c]{
            element \emph{$\ell$}, ${id_i}$ \\
            $\alpha \gets \mathbb{F}_{\phi(p)}$}};
      \node[anchor=east] at (mess to) {$H(\ell)^{K_1 \alpha}$};

      \postlevel
      \postlevel
      \postlevel
      \mess{A}{\shortstack[l]{$\{g^{r_j \alpha} H(\ell)^{c_j \alpha}\}_{j = 0, \dots, t-1}$\\$\{g^{r'_j \alpha} H(\ell)^{c'_j \alpha}\}_{j = 0, \dots, t-1}$ }}{B}
      \node[anchor=east] at (mess from) {\shortstack[c]{
      $r_j \gets \mathbb{Z}_{p}$, Global $c_j$s, $c_0 = K_1$ \\
      $r'_j \gets \mathbb{Z}_{p}$, Global $c'_j$s, $c'_0 = K_1$
      }};
      \node[anchor=west] at (mess to) {\shortstack[l]{
      $\{g^{r_j} H(\ell)^{c_j}\}_{j = 0, \dots, t-1}$\\
      $\{g^{r'_j} H(\ell)^{c'_j}\}_{j = 0, \dots, t-1}$
      }}; 
      
      \postlevel
      \postlevel
      \postlevel
      \postlevel
      \postlevel
      \mess{B}{\shortstack[c]{$\{Enc_{pk}[g^{r_j} (id_i)^j  H(\ell)^{c_j}]\}_{j = 0, \dots, t-1}$\\ $\{Enc_{pk}[g^{r'_j} (id_i)^j  H(\ell)^{c'_j}]\}_{j = 0, \dots, t-1}$}}{A}
      \node[anchor=west] at (mess from) {\shortstack[l]{
            Enc: homomorphic \\encryption scheme}};
      \node[anchor=east] at (mess to) {
      \shortstack[l]{
      %($\times Enc_{pk}[g^{-r_1}]$, $\times Enc_{pk}[g^{-r_2}]$) : 
      \vspace{0.8em}\\
      $\{Enc_{pk}[(id_i)^j H(\ell)^{c_j}]\}_{j = 0, \dots, t-1}$ \vspace{0.5em}\\
      $\{Enc_{pk}[(id_i)^j H(\ell)^{c'_j}]\}_{j = 0, \dots, t-1}$}};

      \postlevel
      \postlevel
      \postlevel
      \postlevel
      \postlevel
      \postlevel
      \mess{A}{\shortstack[c]{$P(id_i)$\\$P'(id_i)$}}{B}
      \node[anchor=east] at (mess from) {\shortstack[r]{
       $P(x) = \sum\limits_{j = 0, \dots, t-1} Enc[x^j H(\ell)^{c_j}] $\\
       \vspace{1em}\\
       $P'(x) = \sum\limits_{j = 0, \dots, t-1} Enc[x^j H(\ell)^{c'_j}] $}};
      \node[anchor=west] at (mess to) {\shortstack[c]{$Share_i(\ell) = Dec_{sk}[P(id_i)]$\\
      $MAC_i(\ell) = Dec_{sk}[P'(id_i)]$}};    
      \sdend{}
   \end{tikzpicture}
   \caption{Communication between the key holder and a participant $id_i$ in Scheme 2 - Share generation for an element $\ell \in \mathbb{L}_i$, owned by $id_i$}
   \label{fig:S1_ShareGen}
\end{figure}
\begin{enumerate}[label=(\alph*)]
    \item Share generation for each element: Party $id_i$ generates a random number $\alpha$ to obliviously send its element's hash value, $H(\ell)$, to the key holder. The key holder generates random numbers $r_1$ and $r_2$\fmargin{*}{I think this needs fixing.} for this session\footnote{In each session, the key holder generates the share and its MAC for an element of a party} to mask the secret value $H(\ell)^{K_1 \alpha}$ and send it to the party. The key holder also uses $t$ global random numbers $c_1, \dots, c_{t-1} \gets \mathbb{Z}_q$ to generate the coefficients of the polynomial $P(x)$ in Shamir secret sharing scheme. We use the term global to indicate that the same random numbers are used in all $mn$ sessions that generate the secret shares for $n$ elements for each of $m$ parties. The key holder communicates with each participant to generate shares for each participant's element using the polynomial $P(x)$. Since the exponentiation is not required for the rest of the protocol, the party removes the $\alpha$ exponent and encrypts the messages using a homomorphic encryption scheme. Figure \ref{fig:S1_ShareGen} shows the protocol taking place between the key holder and a participant with identifier identifier $id_i$, $i =1, \dots, m$, to generate shares for an element $l$. This protocol iterates over all elements $\ell \in \mathbb{L}$ to generate the corresponding share for each element owned by $id_i$.
    \item Share generation for the MAC of each element: As described in MAC generation in Section \ref{ShareGen_S2}(b), our schemes consist of a MAC generation procedure in parallel to the share generation for secrets. The MAC's are used in the reconstruction phase in Section \ref{Recon_S1} to verify the reconstructed secrets. 
\end{enumerate}

\subsubsection{Hashing-to-bins}\label{Binning_S1} This step is identical to the hashing-to-bins described in Section \ref{Binning_S2}.

\subsubsection{Reconstruction}\label{Recon_S1}
The reconstruction procedure of Scheme 2 is similar to the reconstruction in Section \ref{Recon_S2} for Scheme 1. Each party's shares are hashed into the corresponding bins, with each bin containing multiple shares of each party. The reconstructor $\mathcal{R}$ --who is also a participant-- reconstructs the secrets in each bin for every $m \choose t$ subset of shares for distinct parties, $id_{i_1}, \dots, id_{i_t}$. In other words, for each $m \choose t$ subset of the shares in the bin from distinct parties, $id_{i_1}, \dots, id_{i_t}$, $\mathcal{R}$ reconstructs the corresponding secret by applying Lagrange interpolation: $\sum^t_{w=0} Share_{i_w}(\cdot)(\prod_{w' \neq w} \frac{-id_{i_{w'}}}{id_{i_w} - id_{i_{w'}}})$. For a set of shares that correspond to element $\ell$, the Lagrange interpolation results in $H(\ell)^{K_1}$. Similarly, $\mathcal{R}$ calculates the corresponding MAC for the selected set of $t$ shares mentioned earlier, which equals $H(\ell)^{K_1}$ as well if the set of shares correspond to the element $\ell$. $\mathcal{R}$ can verify the equality in the result of the Lagrange interpolation on the secret shares with the corresponding results of the MAC shares and validate the secret. These reconstruction steps are summarized in the Algorithm \ref{alg:S1_Recon}.

\begin{algorithm}[h!]
	 \caption[\textsc{Reconstruct\textsubscript{Scheme1}}]{\textsc{Reconstruct\textsubscript{Scheme1}}}\label{alg:S1_Recon}
	 	\begin{algorithmic}[1]
	 	    \InlineComment{$K_1$ is key holder's secret key and $K_2$ is a publicly known key used for MAC generation}
	 		\InlineComment{$H(\cdot)$ is a hash function in share generation}
	 		\InlineComment{$H_B(\cdot)$ is a hash functions used for hashing-to-bin (Section \ref{Binning_S1})}
            \ForEach {Participant $id_i$;  $i = 1, \dots, m$}
                \ForEach {Element $\ell$ owned by $id_i$; $\ell \in \mathbb{L}_i$}
                    \State $id_i$: store $(id_i, Share_i(\ell), MAC_i(\ell), H_B(\ell))$ in the bin number $H_B(\ell)$
                    \State
	 	        \EndFor
	 	    \EndFor 
	 	    \ForEach {Bin $b_z$;  $z = 1, \dots, b$}
	 	        \ForEach {t-subset of quadruples in the bin $b_z$; $\{(id_{i_1}, Share_{i_1}(\ell), MAC_{i_1}(\ell), b_z), \dots, (id_{i_t}, Share_{i_t}(\ell), MAC_{i_t}(\ell), b_z)\}$, where $id_{i_i}$s are distinct,}
	 	            \State $\mathcal{R}$: Apply Lagrange interpolation to  find the corresponding intercept, $Secret_{share}$, for the polynomial that covers the points $\{({i_1}, Share_{i_1}), \dots, ({i_t}, Share_{i_t})\}$
	 	            \State $\mathcal{R}$: Apply Lagrange interpolation to  find the corresponding intercept, $Secret_{MAC}$, for the polynomial that covers the points $\{({i_1}, MAC_{i_1}), \dots, ({i_t}, MAC_{i_t})\}$
	 	            \If {$Secret_{MAC} == Secret_{share}$}{ Reveal that $(id_{i_1}, \dots , id{i_t})$ can reconstruct the $Secret_{share}$ which is $H(\ell)^{K_1}$}
	 	            \EndIf 
	 	        \EndFor
	 	    \EndFor
	 	\end{algorithmic}
\end{algorithm}


\subsubsection{Complexity} We analyse the complexity of Scheme 2 in its base version with a single key holder. The multi key holder scheme is discussed in Section \ref{Multi-Key-Holder}.
\begin{theorem}
The communication complexity of Scheme 2 in the number of rounds is $O(1)$. 
\end{theorem}
\begin{proof}
As shown in Figure \ref{fig:S1_ShareGen}, the communication between the key holder and each party takes places in two rounds, regardless of the number of parties, the number of elements or the threshold. Hence Scheme 2 is $O(1)$. 
\end{proof}
\begin{theorem}
The communication complexity of Scheme 2 in each rounds is $O(nmt)$, where $m$ is the number of parties, $n$ is the maximum size of the set of the elements owned by a party, and $t$ is the threshold in the over-threshold set intersection scheme.  
\end{theorem}
\begin{proof}
As shown in Figure \ref{fig:S1_ShareGen}, the key holder and the party communicate $t+3$ messages in the first round and $t+2$ messages in the second round. This communication is iterated $n$ times for each of $m$ parties to generate share for all of their elements. Hence, Scheme 2 is $O(nmt)$.  
\end{proof}
\begin{theorem}\label{S1_ComputationComplexity}
The computation complexity of Scheme 2 is $O(b m^t (\log{n})^t)$; where $b$ is the number of bins, $m$ is the number of parties, and $t$ is the threshold value in the over-threshold set intersection scheme.
\end{theorem}
\begin{proof}
As described in Algorithm \ref{alg:S1_Recon}, the reconstructor $\mathcal{R}$ forms all possible combinations of $t$ shares from distinct parties in each bin. There are $m \choose t$ ways for choosing a set of $t$ distinct parties out of $m$ of them. Moreover, each of these parties have $\log{n}$ shares in each bin. Hence, forming a set of $t$ shares from distinct parties in a bin takes $m^t (\log{n})^t$ combinations. This procedure iterates $b$ times to cover all the bins. 
\end{proof}

\subsection{Additional Notes}
\label{sec:addnotes}
\subsubsection{Statistical Secret Sharing Scheme}
Our protocol requires switching between two fields to perform the share generation, described in Figures \ref{fig:S1_ShareGen} and \ref{fig:S2_ShareGen}: i) the base prime field $\mathbb{F}_p$ and ii) the field $\mathbb{F}_N$ in which the homomorphic encryption is performed. We use the statistical secret sharing scheme introduced in  \cite{Statistical_SSS} to covert a secret-shared message over a prime field to another field.  Hence, we require $N > 2^\lambda p^2$.
\subsubsection{Multi-Reconstructor Scheme}
We described in Algorithms \ref{alg:S2_Recon} and \ref{alg:S1_Recon} how the reconstructor $\mathcal{R}$ reconstructs the secrets in each bin. We emphasize the reconstruction is not restricted to a single party and can be performed by multiple parties in parallel. 
\subsubsection{Multi key holder Scheme} \label{Multi-Key-Holder}
We can extend our schemes from a single key holder scenario to a multi key holder one. In this extension, all or a subset of all parties form the key holders set. 
We describe this extension only briefly due to space restrictions.
The key holders received the initial message from the participant and run a secure computation protocol among themselves using a group key and group random numbers (in Scheme 2).
The group keys $c_j = c_{j,1} + c_{j,2} + \ldots c_{j,k}$ and the group random numbers $r_j = r_{j,1} + r_{j,2} = \ldots r_{j,k}$ (in Scheme 2) are shared additively.
Keyholder $id_i$ holds shares $c_{j,i}$ and $r_{j,i}$.
The $k$ keyholders need to multiply the exponentiation of the participant's message and their key share and finally the sum of their random group shares using a secure computation.
Instead of performing this secure computation using secret-share based secure computation with $O(k^2)$ communication, the parties can form a tree and perform pair-wise multiplications of the key shares with $O(k)$ communication in $O(\log k)$ rounds, since each share is the output of a PRF.
The final multiplication with the sum of the group random shares takes one more round.
The multiplications of the ciphertexts in round 2 of Scheme 2 can again be performed in a tree with $O(k)$ communication in $O(\log k)$ rounds.
%The group key serves as the key holder key $K_1$ in the Schemes 1 and 2 (Figures \ref{fig:S2_ShareGen} and \ref{fig:S1_ShareGen}), and the group random numbers serve as $c_j, c'_j; j=1,\dots,t-1$ in Scheme 1 and as $r_1, r_2, r'_1, r'_2$ and $c_j, c'_j; j=1,\dots,t-1$ in the Scheme 2. 
The multi key holder scheme follows the exact same procedure as in Schemes 1 and 2 otherwise. 
