% From http://tex.stackexchange.com/questions/164707/how-to-use-greek-letters-in-pgf-umlsd-or-generally-terms-starting-with
\renewcommand{\mess}[4][0]{
  \stepcounter{seqlevel}
  \path
  (#2)+(0,-\theseqlevel*\unitfactor-0.7*\unitfactor) node (mess from) {};
  \addtocounter{seqlevel}{#1}
  \path
  (#4)+(0,-\theseqlevel*\unitfactor-0.7*\unitfactor) node (mess to) {};
  \draw[->,>=angle 60] (mess from) -- (mess to) node[midway, above]
  {#3};
  \node (\detokenize{#3} from) at (mess from) {};
  \node (\detokenize{#3} to) at (mess to) {};
}

% From http://tex.stackexchange.com/questions/98525/pgf-umlsd-and-externalize
\newcommand{\sdinit}{%
   \pgfdeclarelayer{umlsd@background}%
   \pgfdeclarelayer{umlsd@threadlayer}%
   \pgfsetlayers{umlsd@background,umlsd@threadlayer,main}%
}
\newcommand{\sdbegin}{%
   \setlength{\unitlength}{1cm}%
   \tikzstyle{sequence}=[coordinate]%
   \tikzstyle{inststyle}=[rectangle, draw, anchor=west, minimum
   height=0.8cm, minimum width=1.6cm, fill=white, 
   drop shadow={opacity=1,fill=black}]%
   \ifpgfumlsdroundedcorners%
      \tikzstyle{inststyle}+=[rounded corners=3mm]%
   \fi%
   \tikzstyle{blockstyle}=[anchor=north west]%
   \tikzstyle{blockcommentstyle}=[anchor=north west, font=\small]%
   \tikzstyle{dot}=[inner sep=0pt,fill=black,circle,minimum size=0.2pt]%
   \global\def\unitfactor{0.6}%
   \global\def\threadbias{center}%
   % reset counters
   \setcounter{preinst}{0}%
   \setcounter{instnum}{0}%
   \setcounter{threadnum}{0}%
   \setcounter{seqlevel}{0}%
   \setcounter{callevel}{0}%
   \setcounter{callselflevel}{0}%
   \setcounter{blocklevel}{0}%
   % origin
   \node[coordinate] (inst0) {};%
}
\newcommand{\sdend}{%
   \begin{pgfonlayer}{umlsd@background}%
      \ifnum\value{instnum}>0%
         \foreach \t [evaluate=\t] in {1,...,\theinstnum}{%
            \draw[dotted] (inst\t) -- ++(0,-\theseqlevel*\unitfactor-2.2*\unitfactor);%
         }%
         
      \fi%
      \ifnum\value{threadnum}>0%
         \foreach \t [evaluate=\t] in {1,...,\thethreadnum}{%
            \path (thread\t)+(0,-\theseqlevel*\unitfactor-0.1*\unitfactor) node (threadend) {};%
            \tikzstyle{threadstyle}+=[threadcolor\t]%
            \drawthread{thread\t}{threadend}%
         }%
      \fi%
   \end{pgfonlayer}%
}

\subsection{Notations and Assumptions}
\begin{itemize}
    \item m = the number of parties each identified by $id_i$; $i = 1, \cdots, m$
    \item n = max size of the set of elements, $\mathbb{L}_i$, owned by $id_i$; $i = 1, \cdots, m$
    \item t = threshold (intersection and the secret sharing threshold)
    \item b = number of bins; $b_1, \cdots, b_b$
    \item Each bin is padded to max
    \item Key holder is semi-honest
    \item Key holder is not a party
    \item Key holder sees at most t-1 shares
\end{itemize}
\subsection{Scheme 1}
Set up: field $\mathbb{F}$ with prime p, generator g, hash functions $H(\cdot)$ is used in share generation and $H_B(\cdot)$ is used for hashing-to-bins, global randomnesses: i) key holder: $K_1$ and $K_2$; $K_1$ is just known by key holder, but $k_2$ is known by all, ii) the random numbers $r_1, \cdots, r_{t-1} \gets \mathbb{F}_p$ generated by the key holder, that are fixed for all participants and their all elements. Participants use a homomorphic encryption scheme, Enc, with pubic and private keys $pk, sk$.
\subsubsection{Share Generation}\label{ShareGen_S1}
The key holder generates random numbers $r_1, \cdots, r_{t-1} \gets \mathbb{F}_p$. Then it communicates with each participant to generate shares for each participant's element using Shamir secret sharing scheme. Figure \ref{fig:S1_ShareGen} shows the protocol taking place between the key holder and a participant with identifier identifier $id_i$, $i =1, \cdots, m$, to generate shares for an element $l$. This protocol iterates over all elements $l \in \mathbb{L}$ to generate the corresponding share for each element owned by $id_i$.
\begin{figure}[h!]
   \centering
   \sdinit{}
   \begin{tikzpicture}
      % Define symbols and names for the parties
      \sdbegin{}
      \newinst{A}{Key holder}
      \newinst[5]{B}{Participant} % Increase "5" to widen
      
    % Message from B to A, with computations by both sides
      \postlevel
      \mess{B}{$H(l)^\alpha, g^\alpha $}{A}
      \node[anchor=west] at (mess from) {\shortstack[c]{
            element \emph{l}, ${id_i}$ \\
            $\alpha \gets \mathbb{F}_p$}};
      \node[anchor=east] at (mess to) {$H(l)^{K_1 \alpha}$};
      
      % Message from A to B, with precomputations
      \postlevel
      \mess{A}{$g^{r \alpha}  H(l)^{K_1 \alpha}$}{B}
      \node[anchor=east] at (mess from) {$r \gets \mathbb{F}_p$};
      \node[anchor=west] at (mess to) {$g^{r} H(l)^{K_1}$};

      \postlevel
      \mess{B}{$Enc_{pk}[g^r H(l)^{K_1}]$}{A}
      \node[anchor=west] at (mess from) {\shortstack[l]{
            Enc: homomorphic \\encryption scheme}};
      \node[anchor=east] at (mess to) {$Enc_{pk}[H(l)^{K_1}]$};

      \postlevel
      \postlevel
      \mess{A}{\shortstack[l]{$\{g^{r \alpha} H(l)^{r_j \alpha}\}_{j = 1, \cdots, t-1}$\\$\{g^{r \alpha} H(l)^{r'_j \alpha}\}_{j = 1, \cdots, t-1}$ }}{B}
      \node[anchor=east] at (mess from) {\shortstack[l]{
      For global $r_j$s\\
      And global $r'_j$s
      }};
      \node[anchor=west] at (mess to) {\shortstack[l]{
      $\{g^{r} H(l)^{r_j}\}_{j = 1, \cdots, t-1}$\\
      $\{g^{r} H(l)^{r'_j}\}_{j = 1, \cdots, t-1}$
      }}; 
      
      \postlevel
      \postlevel
      \postlevel
      \mess{B}{\shortstack[l]{$\{Enc_{pk}[g^{r}  H(l)^{r_j}]\}_{j = 1, \cdots, t-1}$\\$\{Enc_{pk}[g^{r}  H(l)^{r'_j}]\}_{j = 1, \cdots, t-1}$}}{A}
      \node[anchor=west] at (mess from) {\shortstack[l]{
            Enc: homomorphic \\encryption scheme}};
      \node[anchor=east] at (mess to) {\shortstack[l]{
      $\{Enc_{pk}[H(l)^{r_j}]\}_{j = 1, \cdots, t-1}$\\
      $\{Enc_{pk}[H(l)^{r'_j}]\}_{j = 1, \cdots, t-1}$}};

      \postlevel
      \postlevel
      \postlevel
      \mess{A}{\shortstack[c]{$P(id_i)$\\$P'(id_i)$}}{B}
      \node[anchor=east] at (mess from) {\shortstack[r]{
       $P(x) = \sum_{}x^j Enc[H(l)^{r_j}] $\\
       $ + Enc[H(l)^{K_1}]$
       \vspace{.3em}
       \\$P'(x) = \sum_{}x^j Enc[H(l)^{r'_j}] $\\
       $+ Enc[H(l)^{K_1K_2}]$}};
      \node[anchor=west] at (mess to) {\shortstack[c]{$Share_i(l) = Dec_{sk}[P(id_i)]$\\
      $MAC_i(l) = Dec_{sk}[P'(id_i)]$}};        
      \sdend{}
   \end{tikzpicture}
   \caption{Communication between the key holder and a participant $id_i$ in scheme 1 - Share generation for an element $l \in \mathbb{L}_i$, owned by $id_i$}
   \label{fig:S1_ShareGen}
\end{figure}

\subsubsection{Hashing-to-bins}\label{Binning_S1}
Participants hash their shares to bins to reduce the computation cost for the reconstructor. Corresponding shares to an element $l$ are stored in bin number $H_B(l)$. Each stored value is a quadruple consisting of i) the participant's identifier, $id_i$, ii) $id_i$'s share for its element $l$, $Share_i(l)$, iii) the corresponding MAC, $MAC_i(l)$, and iv) the number of the bin, $H_B(l)$, that stores the information.

\subsubsection{Reconstruction}\label{Recon_S1}
After each participant stored their shares in the corresponding bins, the reconstructor  $\mathcal{R}$ -- who is also a participant -- reconstructs secrets in each bin. For each $m \choose t$ subset of the participants, $id_{i_1}, \cdots, id_{i_t}$, $\mathcal{R}$ collects the shares and reconstructs the corresponding secret by applying Lagrange interpolation: $H(l)^{k_1} = \sum^t_{w=0} Share_{i_w}(\cdot)(\prod_{w' \neq w} \frac{-id_{i_{w'}}}{id_{i_w} - id_{i_{w'}}})$. Reconstruction's steps are summarized in the Algorithm \ref{alg:S1_Recon}. 

\begin{algorithm}[h!]
	 \caption[\textsc{Reconstruct\textsubscript{Scheme1}}]{\textsc{Reconstruct\textsubscript{Scheme1}}}\label{alg:S1_Recon}
	 	\begin{algorithmic}[1]
	 	    \InlineComment{$K_1$ is key holder's secret key and $K_2$ is a publicly known key used for MAC generation}
	 		\InlineComment{$H(\cdot)$ is a hash function in share generation}
	 		\InlineComment{$H_B(\cdot)$ is a hash functions used for hashing-to-bin (Section \ref{Binning_S1})}
            \ForEach {Participant $id_i$;  $i = 1, \cdots, m$}
                \ForEach {Element $l$ owned by $id_i$; $l \in \mathbb{L}_i$}
                    \State $id_i$: store $(id_i, Share_i(l), MAC_i(l), H_B(l))$ in the bin number $H_B(l)$
                    \State
	 	        \EndFor
	 	    \EndFor 
	 	    \ForEach {Bin $b_z$;  $z = 1, \cdots, b$}
	 	        \ForEach {t-subset of quadruples in the bin $b_z$; $\{(id_{i_1}, Share_{i_1}(l), MAC_{i_1}(l), b_z), \cdots, (id_{i_t}, Share_{i_t}(l), MAC_{i_t}(l), b_z)\}$}
	 	            \State $\mathcal{R}$: Apply Lagrange interpolation to  find the corresponding intercept, $Secret_{share}$, for the polynomial that covers the points $\{({i_1}, Share_{i_1}), \cdots, ({i_t}, Share_{i_t})\}$
	 	            \State $\mathcal{R}$: Apply Lagrange interpolation to  find the corresponding intercept, $Secret_{MAC}$, for the polynomial that covers the points $\{({i_1}, MAC_{i_1}), \cdots, ({i_t}, MAC_{i_t})\}$
	 	            \If {$Secret_{MAC} == (Secret_{share})^{K_2}$}{ Reveal that $(id_{i_1}, \cdots , id{i_t})$ can reconstruct the $Secret_{share}$ which is $H(l)^{K_1}$}
	 	            \EndIf 
	 	        \EndFor
	 	    \EndFor
	 	\end{algorithmic}
\end{algorithm}


\subsubsection{Complexity}
\begin{theorem}
The communication complexity of Scheme 1 is $\cdots$
% $O(nm^2)$ or $O(nmtc)$?
\end{theorem}
\begin{proof}
\end{proof}
\begin{theorem}
The computation complexity of Scheme 1 is $\cdots$
%${m \choose t} n \log{n}^m$.
\end{theorem}
\begin{proof}
\end{proof}

\subsection{Scheme 2}
In this scheme, the polynomial in Shamir secret sharing scheme is calculated in the exponent, the result is eliminating the need to use the homomorphic encryption scheme, Enc. This change reduces the communication cost of the scheme as described in Section \ref{ShareGen_S2}. Similar to Scheme 1, we have the following set up parameters: field $\mathbb{F}$ with prime p, generator g, hash functions $H(\cdot)$ is used in share generation and $H_B(\cdot)$ is used for hashing-to-bins, global randomnesses: i) key holder: $K_1$ and $K_2$; $K_1$ is just known by key holder, but $k_2$ is known by all, ii) the random numbers $r_1, \cdots, r_{t-1} \gets \mathbb{F}_p$ generated by the key holder, that are fixed for all participants and their all elements. 

\subsubsection{Share Generation}\label{ShareGen_S2}
\begin{figure}[h!]
   \centering
   \sdinit{}
   \begin{tikzpicture}
      % Define symbols and names for the parties
      \sdbegin{}
      \newinst{A}{Key holder}
      \newinst[5]{B}{Participant} % Increase "5" to widen
      
    % Message from B to A, with computations by both sides
    %   \postlevel
    %   \mess{A}{\shortstack[l]{$\{g^{r_i}\}_{i = 1, \cdots, t-1}$\\$\{g^{r'_i}\}_{i = 1, \cdots, t-1}$ }}{B}
    %   \node[anchor=east] at (mess from) {\shortstack[l]{
    %   For global $r_i$s\\
    %   And global $r'_i$s
    %   }};
    %   \node[anchor=west] at (mess to) {\shortstack[l]{
    %   $\{g^{r_i}\}_{i = 1, \cdots, t-1}$\\
    %   $\{g^{r'_i}\}_{i = 1, \cdots, t-1}$
    %   }}; 
    
      \postlevel
      \postlevel
      \mess{B}{$H(l)^\alpha$}{A}
    %   \mess{B}{\shortstack[l]{$H(l)^\alpha , \{g^{r_i \alpha}\}_{i = 1, \cdots, t-1}$ \\ $H(l)^\alpha , \{g^{r'_i \alpha}\}_{i = 1, \cdots, t-1}$}}{A}      
       \node[anchor=west] at (mess from) {\shortstack[c]{
            element \emph{l}, \emph{id} \\
            $\alpha \gets \mathbb{F}_p$}};
    \node[anchor=east] at (mess to) {\shortstack[l]{$H(l)^{\alpha K_1}, \{H(l)^{r_i \alpha}\}_{i = 1, \cdots, t-1}$ \\ $H(l)^{\alpha K_1 K_2}, \{H(l)^{r'_i \alpha}\}_{i = 1, \cdots, t-1}$}};
    %   \node[anchor=east] at (mess to) {\shortstack[l]{$H(l)^{\alpha K_1}, \{g^{r_i \alpha}\}_{i = 1, \cdots, t-1}$ \\ $H(l)^{\alpha K_1 K_2}, \{g^{r'_i \alpha}\}_{i = 1, \cdots, t-1}$}};
      
      \postlevel
      \postlevel
      \mess{A}{\shortstack[c]{$P(id)$\\$P'(id)$}}{B}
      \node[anchor=east] at (mess from) {\shortstack[r]{
       $P(x) = H(l)^{\alpha \sum_{}r_i x^i} H(l)^{\alpha K_1}$
       \vspace{.4em}
       \\$P'(x) = H(l)^{\alpha \sum_{}r'_i x^i} H(l)^{\alpha K_1 K_2}$}};
      \node[anchor=west] at (mess to) {\shortstack[c]{$Share(l) = P(id)^{1/ \alpha}$\\
      $MAC(l) = P'(id)^{1/ \alpha}$}};        
      
      \sdend{}
   \end{tikzpicture}
   \caption{Communication between the key holder and a participant $id_i$ in scheme 2 - Share generation for an element $l \in \mathbb{L}_i$, owned by $id_i$}
   \label{fig:S2_ShareGen}
\end{figure}
The key holder generates random numbers $r_1, \cdots, r_{t-1} \gets \mathbb{F}_p$. Then it communicates with each participant to generate shares for each participant's element using Shamir secret sharing scheme, by forming a polynomial in the exponent. Figure \ref{fig:S2_ShareGen} shows the protocol taking place between the key holder and a participant with identifier identifier $id_i$, $i =1, \cdots, m$, to generate shares for an element $l$. This protocol iterates over all elements $l \in \mathbb{L}$ to generate the corresponding share for each element owned by $id_i$.

\subsubsection{Hashing-to-bins}\label{Binning_S2} This step is identical to the hashing-to-bins described in Section \ref{Binning_S1}.

\subsubsection{Reconstruction}\label{Recon_S2}
Similar to the reconstruction in Section \ref{Recon_S1} for Scheme 1, each participant stores their shares in the corresponding bins. Then the reconstructor $\mathcal{R}$ --who is also participant-- reconstructs the secrets in each bin for every $m \choose t$ subset of the participants, $id_{i_1}, \cdots, id_{i_t}$, $\mathcal{R}$. As the polynomial is in the exponent of the generator in this scheme, the reconstructor applies the Lagrange interpolation in the exponent to calculate the secret as follows: $H(l)^{k_1} = \prod^t_{w=0} Share_{i_w}(\cdot)^{(\prod_{w' \neq w} \frac{-id_{w'}}{id_w - id_{w'}})}$.

\begin{algorithm}[h!]
	 \caption[\textsc{Reconstruct\textsubscript{Scheme2}}]{\textsc{Reconstruct\textsubscript{Scheme2}}}\label{alg:S2_Recon}
	 	\begin{algorithmic}[1]
	 	    \InlineComment{$K_1$ is key holder's secret key and $K_2$ is a publicly known key used for MAC generation}
	 		\InlineComment{$H(\cdot)$ is a hash function in share generation}
	 		\InlineComment{$H_B(\cdot)$ is a hash functions used for hashing-to-bin (Section \ref{Binning_S1})}
            \ForEach {Participant $id_i$;  $i = 1, \cdots, m$}
                \ForEach {Element $l$ owned by $id_i$; $l \in \mathbb{L}_i$}
                    \State $id_i$: store $(id_i, Share_i(l), MAC_i(l), H_B(l))$ in the bin number $H_B(l)$
                    \State
	 	        \EndFor
	 	    \EndFor 
	 	    \ForEach {Bin $b_z$;  $z = 1, \cdots, b$}
	 	        \ForEach {t-subset of quadruples in the bin $b_z$; $\{(id_{i_1}, Share_{i_1}(l), MAC_{i_1}(l), b_z), \cdots, (id_{i_t}, Share_{i_t}(l), MAC_{i_t}(l), b_z)\}$}
	 	            \State $\mathcal{R}$: Reconstruct the corresponding secret, $Secret_{share}$, to the points $\{({i_1}, Share_{i_1}), \cdots, ({i_t}, Share_{i_t})\}$
	 	            \State $\mathcal{R}$: Reconstruct the corresponding secret, $Secret_{MAC}$, to the points $\{({i_1}, MAC_{i_1}), \cdots, ({i_t}, MAC_{i_t})\}$
	 	            \If {$Secret_{MAC} == (Secret_{share})^{K_2}$}{ Reveal that $(id_{i_1}, \cdots , id{i_t})$ can reconstruct the $Secret_{share}$ which is $H(l)^{K_1}$}
	 	            \EndIf 
	 	        \EndFor
	 	    \EndFor
	 	\end{algorithmic}
\end{algorithm}

\subsubsection{Complexity}
\begin{theorem}
The communication complexity of Scheme 2 is $\cdots$.
\end{theorem}
\begin{proof}
\end{proof}
\begin{theorem}
The computation complexity of Scheme 2 is $\cdots$.
\end{theorem}
\begin{proof}
\end{proof}
