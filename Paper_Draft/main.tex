\documentclass[10pt, sigconf]{acmart}
\settopmatter{printacmref=false}
\renewcommand\footnotetextcopyrightpermission[1]{} 
\usepackage[utf8]{inputenc}
\usepackage{comment}
\usepackage{multirow}
\usepackage{pifont}
\usepackage{xifthen}
\usepackage[underline=false]{pgf-umlsd}
\usepackage{tikz}
\usepackage{algorithm}
\usepackage[noend]{algpseudocode}
\usepackage{algpseudocode}
\newcommand{\formatcomment}[1]{\scriptsize\textcolor{blue!25!black}{\texttt{#1}}}
\newcommand{\InlineComment}[1]{\vspace*{0.5ex}\State\formatcomment{/*\,#1\,*/}\vspace*{0.5ex}}
\algrenewcommand{\algorithmiccomment}[1]{\hfill\parbox{5.2cm}{\formatcomment{//\,#1}}}
\algrenewcommand\algorithmicprocedure{\textbf{algorithm}}
\algnewcommand\algorithmicforeach{\textbf{for each}}
\algdef{S}[FOR]{ForEach}[1]{\algorithmicforeach\ #1\ \algorithmicdo}
\usepackage{enumitem}
\usepackage[lambda ,advantage, operators, sets , adversary, landau, probability, notions, logic, ff , mm, primitives, events, complexity, asymptotics, keys]{cryptocode}
\usepackage{booktabs} % For formal tables
%\usepackage{color,soul}
\usepackage{comment}
\usepackage{amssymb}
\usepackage[normalem]{ulem} % use normalem to protect \emph
 \newcommand{\superscript}[1]{\ensuremath{{}^{\textrm{\scriptsize #1}}}}
 \newcommand{\roughtext}[1]{\begin{color}{SkyBlue}#1\end{color}}
 \newcommand{\mntext}[1]{\colorbox{SkyBlue}{\begin{color}{black}#1\end{color}}}
 \newcommand{\mn}[2][]{{\tiny\superscript{\mntext{\arabic{mn}}}}\marginpar{\scriptsize{
 			\ifthenelse{\isempty{#1}}
 			{\mntext{\parbox{0.95\marginparwidth}{\superscript{\arabic{mn}}~\raggedright{#2}}}}
 			{\mntext{\parbox{0.95\marginparwidth}{\superscript{\arabic{mn}}#1 says~:~\raggedright{#2}}}}
 		}}\stepcounter{mn}}
 \newcommand{\cryptost}{\mathsf{st}}

\newcommand{\bmargin}[2]{\textcolor{purple}{\ensuremath{^{#1}}}\marginpar{\scriptsize \raggedright \textcolor{purple}{\ensuremath{^{#1}}Bailey: #2}}}
\newcommand{\fmargin}[2]{\textcolor{green}{\ensuremath{^{#1}}}\marginpar{\scriptsize \raggedright \textcolor{green}{\ensuremath{^{#1}}Florian: #2}}}


\title{Over-Threshold Multi-Party Private Set Intersection}
\date{}
\usepackage{natbib}
\usepackage{graphicx}
\onecolumn

\begin{document}
\pagestyle{plain} % removes running headers
\onecolumn
\begingroup
\centering
{\Huge Practical Over-Threshold Multi-Party Private Set Intersection}\\[3em]
\endgroup
% \maketitle
% \begin{abstract}
% \end{abstract}

\section{Introduction}

Two-party private set intersections are practically deployed for ad conversions \cite{yung15mental}, but multi-party set intersections have many more applications.
However, in many of these applications it is required to learn whether a subset of the parties has an element in common.
This is known as the over-threshold multi-party private set intersection (OT-MP-PSI) problem \cite{Kissner}.
A typical use case is that of collaborating network operation centers.
These centers may want to determine whether they are subject to a common attack by comparing log files of indicators of compromise \cite{burger2014taxonomy}.
An attack is already worth investigating, if it affects a subset of the centers, but not all.
However, exchanging indicators of compromise without probable cause is not an option, since they contain privacy-protected information, such as IP addresses \cite{lah2008are}.
The situation is often complicated by different legislations governing those data centers.
An OT-MP-PSI protocol can identify common indicators of compromise without revealing any information about those that do not pass the threshold.
It is hence privacy-preserving, yet enables the investigation of cyberattacks.

The problem of OT-MP-PSI has been defined and its first protocol has been presented by Kissner and Song \cite{Kissner}.
Let there be $m$ parties each holding a database of $n$ elements.
Determine the elements (and their owners) that occur in at least $t$ databases, but reveal nothing else as long as not more than $k$ parties collude.
Kissner and Song's protocol is not yet practical and no implementation exist.
It is a polynomial-based PSI protocol and requires to factor a polynomial of degree $nm$ over a field.
It requires $O(m)$ rounds and has a communication complexity of $O(nm^3)$.

The problem could also be solved using generic multi-party computation techniques.
We assume that constant round multi-party computation protocols \cite{lindell2019efficient,lindell2016more} are not yet practical, since no implementation exists, and resort to secret shared multi-party protocols, such as SCALE-MAMBA \cite{aly2020scale}.
Using a circuit similar to the one used in PSI based on two-party computation \cite{huang12private}, the optimal circuit size is $O(nm \log^2 nm)$ for $O(n + \log^2 nm)$ rounds or $O(nm \log^2 nm + nmt)$ for $O(\log^2 nm)$ rounds.
The communication complexity is larger by at least a factor of $O(m^2)$ \cite{damgaard2019communication}.
Although, multi-party computation protocols do not require a reconstructions phase, the communication complexity is prohibitive in most cases.

In this paper we present a different construction of OT-MP-PSI.
PSI protocols generally exploit locally computation for efficiency.
Our protocol is not different, but uses oblivious pseudo-random functions (OPRF) and hashing to achieve efficiency.
These techniques are commonly used in efficient two-party PSI protocols \cite{Freedman2016,Kolesnikov,Pinkas}, but have not yet been applied to OT-MP-PSI.
While time complexity $O(n m^t \log^t n)$ of our reconstruction phase is exponential in the threshold $t$, we take care to keep the constants low in order to scale to practical sizes for the envisioned use case of indicator of compromise exchange.
Our protocol is very flexible with tunable parameters for the threshold $t$ and the collusion threshold $k$.
We present a variant with communication complexity $O(nmk)$ and round complexity $O(1)$.
However, the constants in reconstruction prevent scaling to practically relevant problem sizes.
Our improved scheme has communication complexity $O(nmkt)$ and round complexity $O(1)$.
We practically implement and evaluate our protocol showing that the reconstruction phase is feasible for up $m = 10$ parties and a threshold of $t = 5$.
Our construction features a new primitive, we call secret-shared oblivious pseudo-random function (SS-OPRF) which returns a secret share of a PRF in an oblivious protocol.
This primitve may of independent interest in other applications than OT-MP-PSI.

In summary, this paper contributes

\begin{enumerate}

\item a new OT-MP-PSI protocol with communication complexity $O(nmk)$ and round complexity $O(1)$.

\item a new OT-MP-PSI protocol with communication complexity $O(nmkt)$, round complexity $O(1)$ and low constants during the reconstruction phase.

\item a new primitive SS-OPRF which is an OPRF that returns the secret share of a PRF in an oblivious protocol.

\item a practical implementation and evaluation of our new OT-MP-PSI protocol.

\end{enumerate}

The remainder of the paper is structured as follows.



\section{Problem Description}

$m$ parties, each with a set of size at most $n$, would like to compute the set of elements that occur in at least $t$ participants' sets and who the corresponding owners are without revealing elements outside of the threshold intersecting set


\section{Background}
\input{Background}

\section{Protocol Overview}
\input{Algorithm_Mas}

\section{Security}
\input{security}


\section{SS-OPRF}

\subsection{Security Definition}


Requirements: 
-keyholder oblivious
-PRF output should be random (obviously)
- Given (t-1) elements all of them appear random (b/c our ss-oprf has an IT argument and a computatioal argument)
- with $H(x)^k$ and (t-1) shares still appears random 
-with t, cannot use it to solve prf property...


Obliviousness

Random PRF Output

No reconstruction even given PRF

\subsection{SS-OPRF 1}

Rasoul's construction, secret sharing in the exponent

$A -> S: x^r$ \\
$S -> A: x^{rSS(c)}$
$A: x^{SS(c)}$

Not sure I got this right.

Problem reconstruction involves modular exponentiation

\subsection{Security Proof}

\subsection{SS-OPRF 2}

My construction, 2 round protocol

$A -> S: g^r, x^r$ \\
$S -> A: (g^r)^{\log s} x^{rc}$ \\
$A -> S: E(((g^r)^{\log s} x^{rc})^{1/r}) = E(s x^c)$ \\
$S -> A: E(SS(x^c))$

\subsection{Security Proof}

\section{Completing the Protocol}

\subsection{Verifying the Reconstruction of Shares}

Give $x^c$ and $x^{cc'}$, reveal $c'$

\subsection{Distributing S}

Share $c = c_1 c_2 c_3 ...$

Also distribute decryption

\subsection{Reducing the number of possible share combinations}

Use hashing to bin the elements.  Only reconstruct within one bin

\section{Evaluation}

\subsection{SS-OPRF}

Time and communication to compute one SS-OPRF1
Time and communication to compute one SS-OPRF2

\subsection{Reconstruction}

Time to reconstruct OT-SI in the base
Time to reconstruct OT-SI in the exponent

\section{Related Work}
\input{Related_Work}

\section{Conclusion}

\bibliographystyle{plain}
\bibliography{references}
\end{document}
